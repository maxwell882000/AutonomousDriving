#!/usr/bin/env python3

import rospy
from sensor_msgs.msg import LaserScan
from std_msgs.msg import Bool,UInt8,Int32
from enum import Enum
from turtlebot3_autorace_core.constants import SIGNS, TASK_PARTS
from turtlebot3_autorace_msgs.msg import MovingParam

class DetectObstacleToRight:
    def __init__(self) -> None:
        # Initialize ROS node
       
        self.is_first = True
        self.cycle_finished = False
        self.once = True
        self.go_forward = True
        self.stopped_once = True
       
        self.mode = SIGNS.IDLE
        self.is_moving_complete = False
        self.is_after_here = False
        self.task_part = 2
        # Subscribe to laser scan data
        rospy.Subscriber('/scan', LaserScan, self.laser_callback)
        self.moving_mode = rospy.Publisher("/control/is_moving", Bool, queue_size= 1)
        self.sub_mode_control = rospy.Subscriber('/core/decided_mode', UInt8, self.cbReceiveMode, queue_size=1)
        self.pub_moving = rospy.Publisher('/control/moving/state', MovingParam, queue_size= 1)
        self.sub_moving_completed = rospy.Subscriber('/control/moving/complete', UInt8, self.cbMovingComplete, queue_size = 1)
        self.stopped_mode = rospy.Publisher("/control/stopped_obstacle", Bool, queue_size= 1)  
        self.pub_flow_task = rospy.Publisher('/core/flow_task', Int32, queue_size=1)
        self.sub_flow_task = rospy.Subscriber('/core/flow_task', Int32, self.setTaskPart, queue_size=1)
        self.update_mode = rospy.Publisher("/control/update_lane", Bool, queue_size= 1)

        
    
    @property
    def is_parking(self):
        return self.mode == SIGNS.PARKING
    
    @property
    def is_cycle(self):
        return self.mode ==SIGNS.CYCLE
    
    @property
    def is_left(self):
        return self.mode == SIGNS.LEFT
    
    @property
    def is_turn(self):
        return self.mode == SIGNS.LEFT or \
        self.mode == SIGNS.RIGHT
        
    def setTaskPart(self, data):
        self.task_part = data.data
    
   
    def cbMovingComplete(self, data):
        self.is_moving_complete = True
        
    def cbReceiveMode(self, mode_msg):
        self.mode = mode_msg.data
        
        rospy.loginfo(self.is_left)
            
    def laser_callback(self, scan_msg):
        # Define the range of laser scan data to check for obstacles
        min_angle = -3.14 # radians
        max_angle = 3.14   # radians
        
        # Find the minimum distance in the specified range
        min_distance = float("inf")
        for i, angle in enumerate(scan_msg.angle_min + scan_msg.angle_increment * i for i in range(len(scan_msg.ranges))):
            if angle > min_angle and angle < max_angle:
                if scan_msg.ranges[i] < min_distance:
                    min_distance = scan_msg.ranges[i]
                    
        min_range = scan_msg.range_max  # initialize to max range    
        min_index = None
        for i, r in enumerate(scan_msg.ranges):
            if r < min_range:
                min_range = r
                min_index = i

        # calculate angle corresponding to object
        if min_index is not None:
            angle = scan_msg.angle_min + min_index * scan_msg.angle_increment
            # convert angle from radians to degrees
            angle_degrees = angle * 180.0 / 3.14

    
        self.cycle_sign(min_distance,angle_degrees)
        
        self.big_turn(min_distance, angle_degrees)
        
        self.go_to_center_for_dynamic_turn(min_distance,angle_degrees)
         
        self.prepare_to_last_turn(min_distance,angle_degrees)
        
        self.parking_finished(min_distance)
           
        

    def cycle_sign(self, min_distance, angle_degrees):
        if not self.cycle_finished and (self.is_cycle or self.is_first == False):
            if (min_distance <= 0.32 and 83 <= angle_degrees <= 93 and self.is_first 
                ) or (not self.is_first and 0.70 < min_distance < 0.90 and 260 < angle_degrees < 275):  # 0.5 meters
                print(min_distance, angle_degrees)
                self.moving_mode.publish(False)
                print("Obstacle detected to the right!")
                if self.is_first == False: 
                    self.cycle_finished = True
                    self.pub_flow_task.publish(TASK_PARTS.BIG_PART)
                self.is_first = False           

    def big_turn(self, min_distance, angle_degrees):
        if self.task_part == TASK_PARTS.BIG_PART and self.go_forward and 0.65 < min_distance < 0.76 \
            and (12 > angle_degrees or angle_degrees > 355):
            self.go_forward = False
            print("Obstacle detected to the front detected!  {}  {}".format(min_distance , angle_degrees))
            rospy.loginfo("go straight")
                        
            msg_moving = MovingParam()
            msg_moving.moving_type=2
            msg_moving.moving_value_angular= angle_degrees - 12  if angle_degrees < 20 else 0
            self.pub_moving.publish(msg_moving)
            self.moving_mode.publish(False)
            while True:
                if self.is_moving_complete == True:
                    break
            self.is_moving_complete = False
            
            rospy.sleep(2)
            
            msg_moving = MovingParam()
            msg_moving.moving_type=4
            msg_moving.moving_value_angular=0
            msg_moving.moving_value_linear= 0.3
            self.pub_moving.publish(msg_moving)
            
            while True:
                if self.is_moving_complete == True:
                    break
            self.is_moving_complete = False
            
            rospy.sleep(2)

            self.stopped_mode.publish(True)
            
    def parking_finished(self, min_distance):
        if self.is_parking and min_distance < 0.15:
            self.moving_mode.publish(False)
        
    def prepare_to_last_turn(self, min_distance, angle_degrees):
        if self.stopped_once and self.is_after_here and self.is_turn and 0.3 < min_distance < 0.38 and (20 > angle_degrees or angle_degrees > 355):
            print("IS stopped mode")
            self.stopped_once = False
            self.moving_mode.publish(False)
            self.stopped_mode.publish(True)
            
    def go_to_center_for_dynamic_turn(self, min_distance, angle_degrees):
        if self.task_part == TASK_PARTS.BIG_PART and self.once and 0.33 < min_distance < 0.37 and 135 < angle_degrees < 144:
            self.once = False

            self.is_after_here = True 
            self.moving_mode.publish(False)
            rospy.sleep(1)
            
            msg_moving = MovingParam()
            msg_moving.moving_type=2
            msg_moving.moving_value_angular=90
            self.pub_moving.publish(msg_moving)

            rospy.sleep(5)
            
            while True:
                if self.is_moving_complete == True:
                    break
            self.is_moving_complete = False
            rospy.sleep(5)

            print("GO FORWARD")
            msg_moving = MovingParam()
            msg_moving.moving_type= 4
            msg_moving.moving_value_linear= 0.2
            self.pub_moving.publish(msg_moving)
            
            while True:
                if self.is_moving_complete == True:
                    break
            self.is_moving_complete = False
            
            rospy.sleep(3)
            
            msg_moving = MovingParam()
            msg_moving.moving_type=3
            msg_moving.moving_value_angular=90
            self.pub_moving.publish(msg_moving)
            
            while True:
                if self.is_moving_complete == True:
                    break
            self.is_moving_complete = False
            rospy.sleep(3)
            msg_moving = MovingParam()
            msg_moving.moving_type=4
            msg_moving.moving_value_angular=0
            msg_moving.moving_value_linear= 0.22
            self.pub_moving.publish(msg_moving)
            
            while True:
                if self.is_moving_complete == True:
                    break
            self.is_moving_complete = False
            
            rospy.sleep(3)
            
            self.pub_flow_task.publish(TASK_PARTS.TURNS)
            self.moving_mode.publish(True)
            self.update_mode.publish(True)
            # rospy.sleep(4)

    def main(self):
        
        # Spin the node
        rospy.spin()
        
if __name__ == '__main__':
    rospy.init_node('core_obstacle', anonymous=True)
    run = DetectObstacleToRight()
    run.main()
